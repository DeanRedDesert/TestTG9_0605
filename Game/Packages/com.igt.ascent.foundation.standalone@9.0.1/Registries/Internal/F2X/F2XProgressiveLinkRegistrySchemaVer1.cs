// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by Xsd2Code++. Version 4.4.0.7
//    <NameSpace>IGT.Game.Core.Registries.Internal.F2X.F2XProgressiveLinkRegistryVer1</NameSpace><Collection>List</Collection><codeType>CSharp</codeType><EnableDataBinding>False</EnableDataBinding><GenerateCloneMethod>False</GenerateCloneMethod><GenerateDataContracts>False</GenerateDataContracts><DataMemberNameArg>OnlyIfDifferent</DataMemberNameArg><DataMemberOnXmlIgnore>False</DataMemberOnXmlIgnore><CodeBaseTag>Net35</CodeBaseTag><InitializeFields>Collections</InitializeFields><GenerateUnusedComplexTypes>True</GenerateUnusedComplexTypes><GenerateUnusedSimpleTypes>True</GenerateUnusedSimpleTypes><GenerateXMLAttributes>True</GenerateXMLAttributes><OrderXMLAttrib>False</OrderXMLAttrib><EnableLazyLoading>False</EnableLazyLoading><VirtualProp>False</VirtualProp><PascalCase>False</PascalCase><AutomaticProperties>False</AutomaticProperties><PropNameSpecified>Default</PropNameSpecified><PrivateFieldName>EndWithField</PrivateFieldName><PrivateFieldNamePrefix></PrivateFieldNamePrefix><EnableRestriction>False</EnableRestriction><RestrictionMaxLenght>False</RestrictionMaxLenght><RestrictionRegEx>False</RestrictionRegEx><RestrictionRange>False</RestrictionRange><ValidateProperty>False</ValidateProperty><ClassNamePrefix></ClassNamePrefix><ClassLevel>Public</ClassLevel><PartialClass>True</PartialClass><ClassesInSeparateFiles>False</ClassesInSeparateFiles><ClassesInSeparateFilesDir></ClassesInSeparateFilesDir><TrackingChangesEnable>False</TrackingChangesEnable><GenTrackingClasses>False</GenTrackingClasses><HidePrivateFieldInIDE>False</HidePrivateFieldInIDE><EnableSummaryComment>True</EnableSummaryComment><EnableAppInfoSettings>False</EnableAppInfoSettings><EnableExternalSchemasCache>True</EnableExternalSchemasCache><EnableDebug>True</EnableDebug><EnableWarn>False</EnableWarn><ExcludeImportedTypes>True</ExcludeImportedTypes><ExpandNesteadAttributeGroup>False</ExpandNesteadAttributeGroup><CleanupCode>True</CleanupCode><EnableXmlSerialization>False</EnableXmlSerialization><SerializeMethodName>Serialize</SerializeMethodName><DeserializeMethodName>Deserialize</DeserializeMethodName><SaveToFileMethodName>SaveToFile</SaveToFileMethodName><LoadFromFileMethodName>LoadFromFile</LoadFromFileMethodName><EnableEncoding>False</EnableEncoding><EnableXMLIndent>False</EnableXMLIndent><IndentChar>Indent2Space</IndentChar><NewLineAttr>False</NewLineAttr><OmitXML>False</OmitXML><Encoder>UTF8</Encoder><Serializer>XmlSerializer</Serializer><sspNullable>False</sspNullable><sspString>False</sspString><sspCollection>False</sspCollection><sspComplexType>False</sspComplexType><sspSimpleType>False</sspSimpleType><sspEnumType>False</sspEnumType><XmlSerializerEvent>False</XmlSerializerEvent><BaseClassName>EntityBase</BaseClassName><UseBaseClass>False</UseBaseClass><GenBaseClass>False</GenBaseClass><CustomUsings>IGT.Game.Core.Registries.Internal.F2X.F2XRegistryTypesVer1</CustomUsings><AttributesToExlude>System.ComponentModel.DefaultValueAttribute</AttributesToExlude>
//  </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable
namespace IGT.Game.Core.Registries.Internal.F2X.F2XProgressiveLinkRegistryVer1
{
    using System;
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System.Collections;
    using System.Xml.Schema;
    using System.ComponentModel;
    using IGT.Game.Core.Registries.Internal.F2X.F2XRegistryTypesVer1;
    using System.Xml;
    using System.Collections.Generic;
    
    
    /// <summary>
    /// Registry for describing progressive linking of game levels to controller levels. The file extension will be called: .xlinkreg.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    [XmlRootAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd", IsNullable=false)]
    public partial class ProgressiveLinkRegistry
    {
        #region Private fields
        private List<LinkMapType> linkMapsField;
        #endregion
        
        /// <summary>
        /// ProgressiveLinkRegistry class constructor
        /// </summary>
        public ProgressiveLinkRegistry()
        {
            linkMapsField = new List<LinkMapType>();
        }
        
        /// <summary>
        /// List of link maps.
        /// </summary>
        [XmlArrayItemAttribute("LinkMap", IsNullable=false)]
        public List<LinkMapType> LinkMaps
        {
            get
            {
                return linkMapsField;
            }
            set
            {
                linkMapsField = value;
            }
        }
    }
    
    /// <summary>
    /// Progressive linking map that specifies the linking of payvar game levels to controller levels.  Includes attributes that specify when the link map may be applied.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class LinkMapType
    {
        #region Private fields
        private LinkMapIdentifierType linkMapIdentifierField;
        private List<OperatorDescriptionLocalizationType> operatorPromptField;
        private ProgressiveConceptIdentifierType progressiveConceptIdentifierField;
        private List<uint> denominationConstraintField;
        private BootConfigurationConstraintType bootConfigurationConstraintField;
        private LinkMapTypeControllerSpecifications controllerSpecificationsField;
        private List<ProgressiveLinkType> progressiveLinksField;
        #endregion
        
        /// <summary>
        /// LinkMapType class constructor
        /// </summary>
        public LinkMapType()
        {
            progressiveLinksField = new List<ProgressiveLinkType>();
            denominationConstraintField = new List<uint>();
            operatorPromptField = new List<OperatorDescriptionLocalizationType>();
        }
        
        /// <summary>
        /// Unique identifier of the link map.
        /// </summary>
        public LinkMapIdentifierType LinkMapIdentifier
        {
            get
            {
                return linkMapIdentifierField;
            }
            set
            {
                linkMapIdentifierField = value;
            }
        }
        
        /// <summary>
        /// Text description to be displayed to the Operator explaining the intended use and/or limitations of the link map.
        /// </summary>
        [XmlArrayItemAttribute("DescriptionLocalization", IsNullable=false)]
        public List<OperatorDescriptionLocalizationType> OperatorPrompt
        {
            get
            {
                return operatorPromptField;
            }
            set
            {
                operatorPromptField = value;
            }
        }
        
        /// <summary>
        /// The progressive concept identifier supported by the link map.
        /// </summary>
        public ProgressiveConceptIdentifierType ProgressiveConceptIdentifier
        {
            get
            {
                return progressiveConceptIdentifierField;
            }
            set
            {
                progressiveConceptIdentifierField = value;
            }
        }
        
        /// <summary>
        /// Denomination constraint.  If omitted, the link map is not constrained by denomination.
        /// </summary>
        [XmlArrayItemAttribute("DenomRequirement", IsNullable=false)]
        public List<uint> DenominationConstraint
        {
            get
            {
                return denominationConstraintField;
            }
            set
            {
                denominationConstraintField = value;
            }
        }
        
        /// <summary>
        /// Boot configuration constraint.  If omitted, the configuration is allowed for all boots.
        /// </summary>
        public BootConfigurationConstraintType BootConfigurationConstraint
        {
            get
            {
                return bootConfigurationConstraintField;
            }
            set
            {
                bootConfigurationConstraintField = value;
            }
        }
        
        /// <summary>
        /// List of controller specifications.  Controller specifications are "demands" of a specific controller (or controller type) that must be satisfy for the "slot" (i.e. payvar+denom) to be playable.  Note that the specified setting are NOT always enforceable due to information limitations that vary by controller, the protocol backing an external controller, or controller protocol version.
        /// </summary>
        public LinkMapTypeControllerSpecifications ControllerSpecifications
        {
            get
            {
                return controllerSpecificationsField;
            }
            set
            {
                controllerSpecificationsField = value;
            }
        }
        
        /// <summary>
        /// The list of game-level to controller-level linking to be applied and/or validated.
        /// </summary>
        [XmlArrayItemAttribute("ProgressiveLink", IsNullable=false)]
        public List<ProgressiveLinkType> ProgressiveLinks
        {
            get
            {
                return progressiveLinksField;
            }
            set
            {
                progressiveLinksField = value;
            }
        }
    }
    
    /// <summary>
    /// The controller endpoint as specified by a controller specification and specification level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ControllerLevelSpecificationType
    {
        #region Private fields
        private string controllerSpecNameField;
        private uint specLevelField;
        #endregion
        
        /// <summary>
        /// A reference to a controller specification element in this link map.
        /// </summary>
        public string ControllerSpecName
        {
            get
            {
                return controllerSpecNameField;
            }
            set
            {
                controllerSpecNameField = value;
            }
        }
        
        /// <summary>
        /// A reference to the level in the ControllerSpecification (zero base index).
        /// </summary>
        public uint SpecLevel
        {
            get
            {
                return specLevelField;
            }
            set
            {
                specLevelField = value;
            }
        }
    }
    
    /// <summary>
    /// The specification of linking of a payvar game level to a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ProgressiveLinkType
    {
        #region Private fields
        private uint gameLevelEndpointField;
        private System.Nullable<LevelIncrementType> incrementTypeField;
        private ProgressiveLinkTypeControllerLevelSpecification controllerLevelSpecificationField;
        private List<LegacyLevelControllerType> legacyLevelSpecificationField;
        #endregion
        
        /// <summary>
        /// ProgressiveLinkType class constructor
        /// </summary>
        public ProgressiveLinkType()
        {
            legacyLevelSpecificationField = new List<LegacyLevelControllerType>();
        }
        
        /// <summary>
        /// Payvar progressive game-level (zero based index.)
        /// </summary>
        public uint GameLevelEndpoint
        {
            get
            {
                return gameLevelEndpointField;
            }
            set
            {
                gameLevelEndpointField = value;
            }
        }
        
        /// <summary>
        /// Type of increment for the game-level.  The type of increment determines whether the progressive level is feed automatically on every bet placed, or will be feed externally by game messaging that specifies contribution values/amounts based on qualifying events determined by the game.   The selection must be in accordance with the controller "IncrementType" otherwise this LinkMap is deemed incorrect.   In case this element is obmitted a WagerBased progressive is assumed.
        /// </summary>
        public LevelIncrementType IncrementType
        {
            get
            {
                if (incrementTypeField.HasValue)
                {
                    return incrementTypeField.Value;
                }
                else
                {
                    return default(LevelIncrementType);
                }
            }
            set
            {
                incrementTypeField = value;
            }
        }
        
        [XmlIgnore]
        public bool IncrementTypeSpecified
        {
            get
            {
                return incrementTypeField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    incrementTypeField = null;
                }
            }
        }
        
        /// <summary>
        /// A reference to a ControllerSpecification element and level in this link map.  Omission of this element specifies either LegacyLevelSpecification is required or the game-level must NOT be linked to any controller level.
        /// </summary>
        public ProgressiveLinkTypeControllerLevelSpecification ControllerLevelSpecification
        {
            get
            {
                return controllerLevelSpecificationField;
            }
            set
            {
                controllerLevelSpecificationField = value;
            }
        }
        
        /// <summary>
        /// Specificiation for this level to be allowed to be linked using legacy (manual) linking.  There is no validation for these levels other than they are connected to one of the specified controllers.  Omission of this element specifies either ControllerLevelSpecification is required or the game-level must NOT be linked to any controller level.
        /// </summary>
        [XmlArrayItemAttribute("Controller", IsNullable=false)]
        public List<LegacyLevelControllerType> LegacyLevelSpecification
        {
            get
            {
                return legacyLevelSpecificationField;
            }
            set
            {
                legacyLevelSpecificationField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifies how the particular level is getting incremented.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum LevelIncrementType
    {
        /// <summary>
        /// The level is increment on each bet of the payvar x denomination.
        /// </summary>
        WagerBased,
        /// <summary>
        /// The level increment is controlled by the Game Client thru the event of adding qualified contribution, the progressive hits are paid and metered as paytable win.
        /// </summary>
        EventBased,
        /// <summary>
        /// The level increment is controlled by the Game Client thru the event of adding qualified contribution, the progressive hits are paid and metered as progressive win.
        /// </summary>
        ProgressiveEventBased,
    }
    
    /// <summary>
    /// A reference to a ControllerSpecification element and level in this link map.  Omission of this element specifies either LegacyLevelSpecification is required or the game-level must NOT be linked to any controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ProgressiveLinkTypeControllerLevelSpecification : ControllerLevelSpecificationType
    {
    }
    
    /// <summary>
    /// Specifies which type of controller this level must be connected to using legacy linking.  The Foundation will validate that this type is connected to this level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum LegacyLevelControllerType
    {
        SAS,
    }
    
    /// <summary>
    /// Specifications required of a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class NetProgressiveControllerSpecLevelType
    {
        #region Private fields
        private string levelNameField;
        private System.Nullable<WapLevelConnectionOptionType> wapLevelConnectionConstraintField;
        private StartValueConstraintType startValueConstraintField;
        private ContributionPercentConstraintType contributionPercentConstraintField;
        #endregion
        
        /// <summary>
        /// A descriptive name for the level specification.  This name field is effectively nothing more than a comment.  It is useful in that it describes what the link map ASSUMES the controller level is used for and can (perhaps) assist the link map designer in identifying the level when providing constraints and assigning game-levels to controller-levels via ProgressiveLink elements.
        /// </summary>
        public string LevelName
        {
            get
            {
                return levelNameField;
            }
            set
            {
                levelNameField = value;
            }
        }
        
        /// <summary>
        /// Specifies whether or not this level must be connected to a WAP level.  This element is IGNORED when connected to a non-WAP controller (i.e. a connected controller is using the non-WAP id value of 40), which may only validly occur when the AllowNonWap attribute is also "true".   WapOnly - The controller level must be a WAP level.   NonWapOnly - The controller level must NOT be a WAP level.  WapOrNonWap - This controller level may be WAP or non-WAP.  If this element is omitted the default is WapOrNonWap.
        /// </summary>
        public WapLevelConnectionOptionType WapLevelConnectionConstraint
        {
            get
            {
                if (wapLevelConnectionConstraintField.HasValue)
                {
                    return wapLevelConnectionConstraintField.Value;
                }
                else
                {
                    return default(WapLevelConnectionOptionType);
                }
            }
            set
            {
                wapLevelConnectionConstraintField = value;
            }
        }
        
        [XmlIgnore]
        public bool WapLevelConnectionConstraintSpecified
        {
            get
            {
                return wapLevelConnectionConstraintField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    wapLevelConnectionConstraintField = null;
                }
            }
        }
        
        /// <summary>
        /// Specifies start/reset value constraints on the controller level.  If omitted the controller level start/reset value is not checked and is always considered valid.
        /// </summary>
        public StartValueConstraintType StartValueConstraint
        {
            get
            {
                return startValueConstraintField;
            }
            set
            {
                startValueConstraintField = value;
            }
        }
        
        /// <summary>
        /// Specifies contribution percentage constraints on the controller level.  If omitted the controller level contribution percentage is not checked and is always considered valid.
        /// </summary>
        public ContributionPercentConstraintType ContributionPercentConstraint
        {
            get
            {
                return contributionPercentConstraintField;
            }
            set
            {
                contributionPercentConstraintField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifies whether or not this level must be connected to a WAP level.  WapOnly - The controller level must be a WAP level.   NonWapOnly - The controller level must NOT be a WAP level.  WapOrNonWap - This controller level may be WAP or non-WAP.  If this element is omitted the default is WapOrNonWap.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum WapLevelConnectionOptionType
    {
        WapOnly,
        NonWapOnly,
        WapOrNonWap,
    }
    
    /// <summary>
    /// Specifies start/reset value constraints on a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class StartValueConstraintType
    {
        #region Private fields
        private object itemField;
        #endregion
        
        [XmlElement("GameLevelStartCreditsScaledByDenom", typeof(StartValueConstraintTypeGameLevelStartCreditsScaledByDenom))]
        [XmlElement("StartAmount", typeof(StartValueConstraintTypeStartAmount))]
        [XmlElement("StartCreditsScaledByDenom", typeof(StartValueConstraintTypeStartCreditsScaledByDenom))]
        public object Item
        {
            get
            {
                return itemField;
            }
            set
            {
                itemField = value;
            }
        }
    }
    
    /// <summary>
    /// Indicates the value from the game-level in the payvar is to be used (scaled by denomination) for comparing to the controller-level value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class StartValueConstraintTypeGameLevelStartCreditsScaledByDenom
    {
        #region Private fields
        private GameLevelAndControllerLevelEnforcementOptionsType enforcementOptionsField;
        private System.Nullable<ControllerRangeEnforcementType> rangeEnforcementField;
        #endregion
        
        /// <summary>
        /// Specifies what is to be done if there is missing information on the game-level or the controller-level.  Strict - Both the game-level specification and the controller-level start values must be known and the check must pass.   RelaxedController - if the controller start/reset value is not known, the check will pass (e.g. custom GCP logic for start values).  RelaxedGameLevel - If the game-level specification is not known (e.g. it is not provided in the payvar file) then the check will pass.  RelaxedControllerAndGameLevel - If either the controller level or the game level value is not known, the check will pass.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public GameLevelAndControllerLevelEnforcementOptionsType EnforcementOptions
        {
            get
            {
                return enforcementOptionsField;
            }
            set
            {
                enforcementOptionsField = value;
            }
        }
        
        /// <summary>
        /// Specifies how strict the range is to be enforced as either ControllerAmountExactMatch or ControllerAmountGreaterThanOrEqual.  If this setting is ControllerGreaterThanOrEqual then the check will pass if the controller amount is greater than or equal to the specified value.  If omitted, the default value is ControllerAmountExactMatch.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerRangeEnforcementType RangeEnforcement
        {
            get
            {
                if (rangeEnforcementField.HasValue)
                {
                    return rangeEnforcementField.Value;
                }
                else
                {
                    return default(ControllerRangeEnforcementType);
                }
            }
            set
            {
                rangeEnforcementField = value;
            }
        }
        
        [XmlIgnore]
        public bool RangeEnforcementSpecified
        {
            get
            {
                return rangeEnforcementField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    rangeEnforcementField = null;
                }
            }
        }
    }
    
    /// <summary>
    /// Specifies what is to be done if there is missing information on the game-level or the controller-level.  Strict - Both the game-level specification and the controller-level values must be known and the check must pass.   RelaxedController - if the controller value is not known, the check will pass.  RelaxedGameLevel - If the game-level specification is not known (e.g. it is not provided in the payvar file) then the check will pass.  RelaxedControllerAndGameLevel - If either the controller level or the game level value is not known, the check will pass.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum GameLevelAndControllerLevelEnforcementOptionsType
    {
        Strict,
        RelaxedController,
        RelaxedGameLevel,
        RelaxedControllerAndGameLevel,
    }
    
    /// <summary>
    /// Specifies how strict the range is to be enforced as either ControllerAmountExactMatch or ControllerAmountGreaterThanOrEqual.  If this setting is ControllerGreaterThanOrEqual then the check will pass if the controller amount is greater than or equal to the specified value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum ControllerRangeEnforcementType
    {
        ControllerAmountExactMatch,
        ControllerAmountGreaterThanOrEqual,
    }
    
    /// <summary>
    /// Directly specifies the expected start value of the controller level as an amount, effectively ignoring the game-level value in the payvar (if any).  The amount is expressed in "base monetary units" which is the smallest value for the currency in the jurisdiction (e.g. cents, Lira, etc.); for example a value of "1" is equal to one cent for US currency.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class StartValueConstraintTypeStartAmount
    {
        #region Private fields
        private ControllerSettingsEnforcementOptionsType enforcementOptionsField;
        private System.Nullable<ControllerRangeEnforcementType> rangeEnforcementField;
        private ulong valueField;
        #endregion
        
        /// <summary>
        /// Specifies what is to be done if there is missing information on the controller-level.  Strict - The controller-level start values must be known and the check must pass.   Relaxed - If the controller-level value is not known, the check will pass  (e.g. custom GCP logic for start values).
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerSettingsEnforcementOptionsType EnforcementOptions
        {
            get
            {
                return enforcementOptionsField;
            }
            set
            {
                enforcementOptionsField = value;
            }
        }
        
        /// <summary>
        /// Specifies how strict the range is to be enforced as either ControllerAmountExactMatch or ControllerAmountGreaterThanOrEqual.  If this setting is ControllerGreaterThanOrEqual then the check will pass if the controller amount is greater than or equal to the specified value.  If omitted, the default value is ControllerAmountExactMatch.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerRangeEnforcementType RangeEnforcement
        {
            get
            {
                if (rangeEnforcementField.HasValue)
                {
                    return rangeEnforcementField.Value;
                }
                else
                {
                    return default(ControllerRangeEnforcementType);
                }
            }
            set
            {
                rangeEnforcementField = value;
            }
        }
        
        [XmlIgnore]
        public bool RangeEnforcementSpecified
        {
            get
            {
                return rangeEnforcementField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    rangeEnforcementField = null;
                }
            }
        }
        
        [XmlTextAttribute]
        public ulong Value
        {
            get
            {
                return valueField;
            }
            set
            {
                valueField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifies what is to be done if there is missing information on the controller level.  Strict - The controller level values must be known and the check must pass.   Relaxed - If the controller level is not known, the check will pass.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum ControllerSettingsEnforcementOptionsType
    {
        Strict,
        Relaxed,
    }
    
    /// <summary>
    /// Directly specifies the expected start value of the controller level as credits.  If present, the controller start amount  is expected to be this elements value as scaled by the denomination, effectively ignoring the game-level start credits in the payvar (if any).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class StartValueConstraintTypeStartCreditsScaledByDenom
    {
        #region Private fields
        private ControllerSettingsEnforcementOptionsType enforcementOptionsField;
        private System.Nullable<ControllerRangeEnforcementType> rangeEnforcementField;
        private ulong valueField;
        #endregion
        
        /// <summary>
        /// Specifies what is to be done if there is missing information on the controller level.  Strict - The controller level start values must be known and the check must pass.   Relaxed - If the controller level is not known, the check will pass  (e.g. custom GCP logic for start values).
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerSettingsEnforcementOptionsType EnforcementOptions
        {
            get
            {
                return enforcementOptionsField;
            }
            set
            {
                enforcementOptionsField = value;
            }
        }
        
        /// <summary>
        /// Specifies how strict the range is to be enforced as either ControllerAmountExactMatch or ControllerAmountGreaterThanOrEqual.  If this setting is ControllerGreaterThanOrEqual then the check will pass if the controller amount is greater than or equal to the specified value.  If omitted, the default value is ControllerAmountExactMatch.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerRangeEnforcementType RangeEnforcement
        {
            get
            {
                if (rangeEnforcementField.HasValue)
                {
                    return rangeEnforcementField.Value;
                }
                else
                {
                    return default(ControllerRangeEnforcementType);
                }
            }
            set
            {
                rangeEnforcementField = value;
            }
        }
        
        [XmlIgnore]
        public bool RangeEnforcementSpecified
        {
            get
            {
                return rangeEnforcementField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    rangeEnforcementField = null;
                }
            }
        }
        
        [XmlTextAttribute]
        public ulong Value
        {
            get
            {
                return valueField;
            }
            set
            {
                valueField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifies contribution percentage constraints on a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ContributionPercentConstraintType
    {
        #region Private fields
        private object itemField;
        #endregion
        
        [XmlElement("ContributionPercent", typeof(ContributionPercentConstraintTypeContributionPercent))]
        [XmlElement("GameLevelContribution", typeof(ContributionPercentConstraintTypeGameLevelContribution))]
        public object Item
        {
            get
            {
                return itemField;
            }
            set
            {
                itemField = value;
            }
        }
    }
    
    /// <summary>
    /// Directly specifies the expected contribution percentage of the controller level.  If present, the controller's contribution percentage is expected to be within the maximum and minimum attributes of this element.  Effectively, the ForcedContribution in the payvar (if any) is ignored.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ContributionPercentConstraintTypeContributionPercent
    {
        #region Private fields
        private ControllerSettingsEnforcementOptionsType enforcementOptionsField;
        private string minimumPercentField;
        private string maximumPercentField;
        #endregion
        
        /// <summary>
        /// Specifies what is to be done if there is missing information on the controller level.  Strict - The controller level contribution percent must be known and the check must pass.   Relaxed - If the controller level is not known, the check will pass  (e.g. custom GCP logic/"event driven" contributions).
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public ControllerSettingsEnforcementOptionsType EnforcementOptions
        {
            get
            {
                return enforcementOptionsField;
            }
            set
            {
                enforcementOptionsField = value;
            }
        }
        
        /// <summary>
        /// Minimum contribution percent (inclusive).
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public string MinimumPercent
        {
            get
            {
                return minimumPercentField;
            }
            set
            {
                minimumPercentField = value;
            }
        }
        
        /// <summary>
        /// Maximum contribution percent (inclusive).
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public string MaximumPercent
        {
            get
            {
                return maximumPercentField;
            }
            set
            {
                maximumPercentField = value;
            }
        }
    }
    
    /// <summary>
    /// Indicates the value for the game level in the payvar is to be used for comparing to the controller level value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class ContributionPercentConstraintTypeGameLevelContribution
    {
        #region Private fields
        private GameLevelAndControllerLevelEnforcementOptionsType enforcementOptionsField;
        private string controllerGreaterToleranceField;
        private string controllerLesserToleranceField;
        #endregion
        
        /// <summary>
        /// Specifies what is to be done if there is missing information on the game-level or the controller-level.  Strict - Both the game-level and the controller-level contribution percentages must be known and the check must pass.   RelaxedController - if the controller contribution percent is not known, the check will pass (e.g. custom GCP logic/"event driven" contributions).  RelaxedGameLevel - If the game-level specification is not known (e.g. it is not provided in the payvar file) then the check will pass.  RelaxedControllerAndGameLevel - If either the controller level or the game level value is not known, the check will pass.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public GameLevelAndControllerLevelEnforcementOptionsType EnforcementOptions
        {
            get
            {
                return enforcementOptionsField;
            }
            set
            {
                enforcementOptionsField = value;
            }
        }
        
        /// <summary>
        /// The controller contribution percent may be greater than the game-level percent by no more than this value or the check will fail.  This value must be specified as a non-negative number.   Example: If game-level contribution is 1.07%, and the tolerance is 0.01 then a controller-level of 1.08 will pass, but anything greater than 1.08 will fail.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public string ControllerGreaterTolerance
        {
            get
            {
                return controllerGreaterToleranceField;
            }
            set
            {
                controllerGreaterToleranceField = value;
            }
        }
        
        /// <summary>
        /// The controller contribution percent may be less than the game-level percent by no more than this value or the check will fail.  This value must be specified as a non-negative number.  Example: If game-level contribution is 1.07%, and the tolerance is 0.01 then a controller-level of 1.07 will pass, but anything less than 1.07 will fail.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public string ControllerLesserTolerance
        {
            get
            {
                return controllerLesserToleranceField;
            }
            set
            {
                controllerLesserToleranceField = value;
            }
        }
    }
    
    /// <summary>
    /// NetProgressive controller specification.  Specifies a controller configuration and/or attributes required to satisfy this link map. This element is specific to Net Progressive Controller types.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class NetProgressiveControllerSpecificationType
    {
        #region Private fields
        private string controllerSpecNameField;
        private NetProgressiveControllerGroupIdentifierType groupIdentifierField;
        private WapConfigurationRequirementsType wapConfigurationRequirementsField;
        private System.Nullable<LevelIncrementType> incrementTypeField;
        private List<NetProgressiveControllerSpecLevelType> netProgressiveControllerSpecLevelsField;
        #endregion
        
        /// <summary>
        /// NetProgressiveControllerSpecificationType class constructor
        /// </summary>
        public NetProgressiveControllerSpecificationType()
        {
            netProgressiveControllerSpecLevelsField = new List<NetProgressiveControllerSpecLevelType>();
        }
        
        /// <summary>
        /// Symbolic name of this controller specification element, for use as a reference by ProgressiveLink elements within this link map (i.e. the scope of this symbol name is local to the link map element only).
        /// </summary>
        public string ControllerSpecName
        {
            get
            {
                return controllerSpecNameField;
            }
            set
            {
                controllerSpecNameField = value;
            }
        }
        
        /// <summary>
        /// Unique identifier to map the game levels to levels within a Net Progressive Controller group (aka "Progressive ID X").
        /// </summary>
        public NetProgressiveControllerGroupIdentifierType GroupIdentifier
        {
            get
            {
                return groupIdentifierField;
            }
            set
            {
                groupIdentifierField = value;
            }
        }
        
        /// <summary>
        /// The list of acceptable WAP configurations.  If the requirements of all WapConfigurationRequirement elements are met, then the configuration is considered acceptable and presented to the operator.  If this element is omitted, then the link map is not valid for a WAP configured controller (i.e. if the game is allowed to be linked to a WAP level, this element must be present). In order to prevent misconfiguration, the range evaluation just determines the possible WapSystemIDs. In case more than one WapSystemID would be allowed, the operator has to pick the intended one within the operator menu before starting the protocol enrollment process. In case only one WapSystemID would be applicable throughout the entire EGM, the selection will be done for the operator.
        /// </summary>
        public WapConfigurationRequirementsType WapConfigurationRequirements
        {
            get
            {
                return wapConfigurationRequirementsField;
            }
            set
            {
                wapConfigurationRequirementsField = value;
            }
        }
        
        /// <summary>
        /// Type of increment for the controller levels. Default is WagerBased.
        /// </summary>
        public LevelIncrementType IncrementType
        {
            get
            {
                if (incrementTypeField.HasValue)
                {
                    return incrementTypeField.Value;
                }
                else
                {
                    return default(LevelIncrementType);
                }
            }
            set
            {
                incrementTypeField = value;
            }
        }
        
        [XmlIgnore]
        public bool IncrementTypeSpecified
        {
            get
            {
                return incrementTypeField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    incrementTypeField = null;
                }
            }
        }
        
        /// <summary>
        /// The list of specifications/requirements for controller levels.  Elements are referenced by a zero based index when used by the ProgressiveLink elements.
        /// </summary>
        [XmlArrayItemAttribute("NetProgressiveControllerSpecLevel", IsNullable=false)]
        public List<NetProgressiveControllerSpecLevelType> NetProgressiveControllerSpecLevels
        {
            get
            {
                return netProgressiveControllerSpecLevelsField;
            }
            set
            {
                netProgressiveControllerSpecLevelsField = value;
            }
        }
    }
    
    /// <summary>
    /// The list of acceptable WAP configurations.  If the requirements of any one of the WapConfigurationRequirement elements are met, then the configuration is considered acceptable and presented to the operator.  If this element is omitted, then the link map is not valid for a WAP configured controller (i.e. if the game is allowed to be linked to a WAP level, this element must be present). In order to prevent misconfiguration, the range evaluation just determines the possible WapSystemIDs. In case more than one WapSystemID would be allowed, the operator has to pick the intended one within the operator menu before starting the protocol enrollment process. In case only one WapSystemID would be applicable throughout the entire EGM, the selection will be done for the operator.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class WapConfigurationRequirementsType
    {
        #region Private fields
        private List<WapConfigurationRequirementType> wapConfigurationRequirementField;
        private bool allowNonWapField;
        #endregion
        
        /// <summary>
        /// WapConfigurationRequirementsType class constructor
        /// </summary>
        public WapConfigurationRequirementsType()
        {
            wapConfigurationRequirementField = new List<WapConfigurationRequirementType>();
        }
        
        /// <summary>
        /// A WAP configuration requirement.  Note that ALL constraint sub-elements must be met for this WapConfigurationRequirement to be met.
        /// </summary>
        [XmlElement("WapConfigurationRequirement")]
        public List<WapConfigurationRequirementType> WapConfigurationRequirement
        {
            get
            {
                return wapConfigurationRequirementField;
            }
            set
            {
                wapConfigurationRequirementField = value;
            }
        }
        
        /// <summary>
        /// If true then a non-WAP configuration is also valid. If false then at least one level must be WAP.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public bool AllowNonWap
        {
            get
            {
                return allowNonWapField;
            }
            set
            {
                allowNonWapField = value;
            }
        }
    }
    
    /// <summary>
    /// A progressive concept requirement.  Note that ALL constraint sub-elements must be met for this ProgressiveConceptRequirement to be met.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class WapConfigurationRequirementType
    {
        #region Private fields
        private WapConfigurationRequirementTypeWapIdConstraint wapIdConstraintField;
        #endregion
        
        /// <summary>
        /// List of valid WAP Ids for this WapConfigurationRequirement.
        /// </summary>
        public WapConfigurationRequirementTypeWapIdConstraint WapIdConstraint
        {
            get
            {
                return wapIdConstraintField;
            }
            set
            {
                wapIdConstraintField = value;
            }
        }
    }
    
    /// <summary>
    /// List of valid WAP Ids for this WapConfigurationRequirement.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class WapConfigurationRequirementTypeWapIdConstraint : WapIdConstraintType
    {
    }
    
    /// <summary>
    /// List of valid Wap ids for this progressive concept requirement.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class WapIdConstraintType
    {
        #region Private fields
        private List<uint> wapSystemIdField;
        private System.Nullable<uint> minimumWapSystemIdField;
        private System.Nullable<uint> maximumWapSystemIdField;
        #endregion
        
        /// <summary>
        /// WapIdConstraintType class constructor
        /// </summary>
        public WapIdConstraintType()
        {
            wapSystemIdField = new List<uint>();
        }
        
        /// <summary>
        /// The valid WAP Id(s) as validated against the controller provided WAP id.  If this element is omitted, then any WAP Id is valid (except the non-WAP id value of 40).  To indicate that all WAP Ids are allowed, plus the special non-WAP Id of 40, this element is omitted and the "AllowNonWap" attribute should be set to "true" in the WapConstraint element. If "MinimumWapSystemId" and/or "MaximumWapSystemId" is provided (without a list of enumerated WAP ids) then all WAP Ids within this range are valid (except 40, which may be include via the "AllowNonWap" attribute).  If a range AND a list are provided, they are considered as an or conjunction.
        /// </summary>
        [XmlElement("WapSystemId")]
        public List<uint> WapSystemId
        {
            get
            {
                return wapSystemIdField;
            }
            set
            {
                wapSystemIdField = value;
            }
        }
        
        /// <summary>
        /// The lower bound of the WapSystemId. Any value less than the given one is not considered valid.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public uint MinimumWapSystemId
        {
            get
            {
                if (minimumWapSystemIdField.HasValue)
                {
                    return minimumWapSystemIdField.Value;
                }
                else
                {
                    return default(uint);
                }
            }
            set
            {
                minimumWapSystemIdField = value;
            }
        }
        
        [XmlIgnore]
        public bool MinimumWapSystemIdSpecified
        {
            get
            {
                return minimumWapSystemIdField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    minimumWapSystemIdField = null;
                }
            }
        }
        
        /// <summary>
        /// The upper bound of the WapSystemId. Any value greater than the given one is not considered valid.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public uint MaximumWapSystemId
        {
            get
            {
                if (maximumWapSystemIdField.HasValue)
                {
                    return maximumWapSystemIdField.Value;
                }
                else
                {
                    return default(uint);
                }
            }
            set
            {
                maximumWapSystemIdField = value;
            }
        }
        
        [XmlIgnore]
        public bool MaximumWapSystemIdSpecified
        {
            get
            {
                return maximumWapSystemIdField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    maximumWapSystemIdField = null;
                }
            }
        }
    }
    
    /// <summary>
    /// Specifications required of a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class IppMLPControllerSpecLevelType
    {
        #region Private fields
        private string levelNameField;
        private System.Nullable<WapLevelConnectionOptionType> wapLevelConnectionConstraintField;
        private StartValueConstraintType startValueConstraintField;
        private ContributionPercentConstraintType contributionPercentConstraintField;
        #endregion
        
        /// <summary>
        /// A descriptive name for the level specification.  This name field is effectively nothing more than a comment.  It is useful in that it describes what the link map ASSUMES the controller level is used for and can (perhaps) assist the link map designer in identifying the level when providing constraints and assigning game-levels to controller-levels via ProgressiveLink elements.
        /// </summary>
        public string LevelName
        {
            get
            {
                return levelNameField;
            }
            set
            {
                levelNameField = value;
            }
        }
        
        /// <summary>
        /// Specifies whether or not this level must be connected to a WAP level.  This element is IGNORED when connected to a non-WAP controller (i.e. a connected controller is using the non-WAP id value of 40), which may only validly occur when the AllowNonWap attribute is also "true".   WapOnly - The controller level must be a WAP level.   NonWapOnly - The controller level must NOT be a WAP level.  WapOrNonWap - This controller level may be WAP or non-WAP.  If this element is omitted the default is WapOrNonWap.
        /// </summary>
        public WapLevelConnectionOptionType WapLevelConnectionConstraint
        {
            get
            {
                if (wapLevelConnectionConstraintField.HasValue)
                {
                    return wapLevelConnectionConstraintField.Value;
                }
                else
                {
                    return default(WapLevelConnectionOptionType);
                }
            }
            set
            {
                wapLevelConnectionConstraintField = value;
            }
        }
        
        [XmlIgnore]
        public bool WapLevelConnectionConstraintSpecified
        {
            get
            {
                return wapLevelConnectionConstraintField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    wapLevelConnectionConstraintField = null;
                }
            }
        }
        
        /// <summary>
        /// Specifies start/reset value constraints on the controller level.  If omitted the controller level start/reset value is not checked and is always considered valid.
        /// </summary>
        public StartValueConstraintType StartValueConstraint
        {
            get
            {
                return startValueConstraintField;
            }
            set
            {
                startValueConstraintField = value;
            }
        }
        
        /// <summary>
        /// Specifies contribution percentage constraints on the controller level.  If omitted the controller level contribution percentage is not checked and is always considered valid.
        /// </summary>
        public ContributionPercentConstraintType ContributionPercentConstraint
        {
            get
            {
                return contributionPercentConstraintField;
            }
            set
            {
                contributionPercentConstraintField = value;
            }
        }
    }
    
    /// <summary>
    /// IPP MLP controller specification.  Specifies a controller configuration and/or attributes required to satisfy this link map. MLP refers to non-zero bonus WAP, sometimes called bonus IPP.  The controller specification applies only to the IPP Protocol v8.2.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class IppMLPControllerSpecificationType
    {
        #region Private fields
        private string controllerSpecNameField;
        private string bonusTypeField;
        private WapConfigurationRequirementsType wapConfigurationRequirementsField;
        private List<IppMLPControllerSpecLevelType> ippMLPControllerSpecLevelsField;
        #endregion
        
        /// <summary>
        /// IppMLPControllerSpecificationType class constructor
        /// </summary>
        public IppMLPControllerSpecificationType()
        {
            ippMLPControllerSpecLevelsField = new List<IppMLPControllerSpecLevelType>();
        }
        
        /// <summary>
        /// Symbolic name of this controller specification element, for use as a reference by ProgressiveLink elements within this link map (i.e. the scope of this symbol name is local to the link map element only).
        /// </summary>
        public string ControllerSpecName
        {
            get
            {
                return controllerSpecNameField;
            }
            set
            {
                controllerSpecNameField = value;
            }
        }
        
        /// <summary>
        /// The bonus type (e.g. the "IPC theme code") expressed in 2 digit hex notation (e.g. enter "0x0B" for "Indiana Jones" bonus type as per IPP/IPC Protocol Version 8.2 protoocol documentation).  This value is validated against the values sent by the external controller. A bonus code is currently needed for any IPP connection.
        /// </summary>
        public string BonusType
        {
            get
            {
                return bonusTypeField;
            }
            set
            {
                bonusTypeField = value;
            }
        }
        
        /// <summary>
        /// The list of acceptable WAP configurations.  If the requirements of all WapConfigurationRequirement elements are met, then the configuration is considered acceptable and presented to the operator.  If this element is omitted, then the link map is not valid for a WAP configured controller (i.e. if the game is allowed to be linked to a WAP level, this element must be present). In order to prevent misconfiguration, the range evaluation just determines the possible WapSystemIDs. In case more than one WapSystemID would be allowed, the operator has to pick the intended one within the operator menu before starting the IPP enrollment. In case only one WapSystemID would be applicable throughout the entire EGM, the selection will be done for the operator.
        /// </summary>
        public WapConfigurationRequirementsType WapConfigurationRequirements
        {
            get
            {
                return wapConfigurationRequirementsField;
            }
            set
            {
                wapConfigurationRequirementsField = value;
            }
        }
        
        /// <summary>
        /// The list of specifications/requirements for controller levels.  Elements are referenced by a zero based index when used by the ProgressiveLink elements.
        /// </summary>
        [XmlArrayItemAttribute("IppMLPControllerSpecLevel", IsNullable=false)]
        public List<IppMLPControllerSpecLevelType> IppMLPControllerSpecLevels
        {
            get
            {
                return ippMLPControllerSpecLevelsField;
            }
            set
            {
                ippMLPControllerSpecLevelsField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifications required of a controller level.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class SpcControllerSpecLevelType
    {
        #region Private fields
        private string levelNameField;
        private StartValueConstraintType startValueConstraintField;
        private ContributionPercentConstraintType contributionPercentConstraintField;
        #endregion
        
        /// <summary>
        /// A descriptive name for the level specification.  This name field is effectively nothing more than a comment.  It is not displayed to the operator, and it is not used in string matching against SPC level names (as instantiated by the F2XSpcGroup registry).  It is useful in that it describes what the link map ASSUMES the controller level is used for and can (perhaps) assist the link map designer in identifying the level when providing constraints and assigning game-levels to controller-levels via ProgressiveLink elements.
        /// </summary>
        public string LevelName
        {
            get
            {
                return levelNameField;
            }
            set
            {
                levelNameField = value;
            }
        }
        
        /// <summary>
        /// Specifies start/reset value constraints on the controller level.  If omitted the controller level start/reset value is not checked and is always considered valid.
        /// </summary>
        public StartValueConstraintType StartValueConstraint
        {
            get
            {
                return startValueConstraintField;
            }
            set
            {
                startValueConstraintField = value;
            }
        }
        
        /// <summary>
        /// Specifies contribution percentage constraints on the controller level.  If omitted the controller level contribution percentage is not checked and is always considered valid.
        /// </summary>
        public ContributionPercentConstraintType ContributionPercentConstraint
        {
            get
            {
                return contributionPercentConstraintField;
            }
            set
            {
                contributionPercentConstraintField = value;
            }
        }
    }
    
    /// <summary>
    /// This element identifies the Standalone Progressive Controller group that is to be compared against the controller specifications.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class SpcTargetType
    {
        #region Private fields
        private object itemField;
        #endregion
        
        [XmlElement("SpcGroupIdentifier", typeof(SpcGroupIdentifierType))]
        [XmlElement("SpcGroupTemplateIdentifier", typeof(SpcGroupTemplateIdentifierType))]
        public object Item
        {
            get
            {
                return itemField;
            }
            set
            {
                itemField = value;
            }
        }
    }
    
    /// <summary>
    /// Standalone Progressive Controller specification.  Specifies a controller configuration and/or attributes required to satisfy a link map.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class SpcControllerSpecificationType
    {
        #region Private fields
        private string controllerSpecNameField;
        private System.Nullable<LevelIncrementType> incrementTypeField;
        private SpcTargetType spcTargetField;
        private List<SpcControllerSpecLevelType> spcControllerSpecLevelsField;
        #endregion
        
        /// <summary>
        /// SpcControllerSpecificationType class constructor
        /// </summary>
        public SpcControllerSpecificationType()
        {
            spcControllerSpecLevelsField = new List<SpcControllerSpecLevelType>();
        }
        
        /// <summary>
        /// Symbolic name of this controller specification element, for use as a reference by ProgressiveLink elements within this link map (i.e. the scope of this symbol name is local to the link map element only).
        /// </summary>
        public string ControllerSpecName
        {
            get
            {
                return controllerSpecNameField;
            }
            set
            {
                controllerSpecNameField = value;
            }
        }
        
        /// <summary>
        /// Type of increment for the controller.  The type of increment determines whether the progressive controller is feed automatically on every bet placed, or will be feed externally by game messaging that specifies contribution values/amounts based on qualifying events determined by the game.   In case "EventBased" is selected, there will be no WapConfigurationRequirements allowed for the controller specification.   Note: Either the entire controller is "EventBased" or the controller is "WagerBased".   In case this element is obmitted a WagerBased progressive controller is assumed.
        /// </summary>
        public LevelIncrementType IncrementType
        {
            get
            {
                if (incrementTypeField.HasValue)
                {
                    return incrementTypeField.Value;
                }
                else
                {
                    return default(LevelIncrementType);
                }
            }
            set
            {
                incrementTypeField = value;
            }
        }
        
        [XmlIgnore]
        public bool IncrementTypeSpecified
        {
            get
            {
                return incrementTypeField.HasValue;
            }
            set
            {
                if (value==false)
                {
                    incrementTypeField = null;
                }
            }
        }
        
        /// <summary>
        /// This element identifies the Standalone Progressive Controller group that is to be compared against the controller specifications.
        /// </summary>
        public SpcTargetType SpcTarget
        {
            get
            {
                return spcTargetField;
            }
            set
            {
                spcTargetField = value;
            }
        }
        
        /// <summary>
        /// The list of specifications/requirements for controller levels.  Elements are referenced by a zero based index and correspond index-to-index to SPC controller levels.  Some applications may require "placeholder" elements containing no constraints.  For example, if validation is needed for controller levels 0 and 2 (but not level 1), three SpcControllerSpecLevel elements would still be required with the second element representing controller level 1 and serving as a placeholder (i.e. the second element would have no constraints).  Note that the existence of a placeholder element is, of itself, a constraint in that it specifies that the level must exist on the controller.  For example, if four SpcControllerSpecLevel elements are present, then the referenced SPC group must contain at least four levels, even if all the SpcControllerSpecLevel elements are just placeholders.
        /// </summary>
        [XmlArrayItemAttribute("SpcControllerSpecLevel", IsNullable=false)]
        public List<SpcControllerSpecLevelType> SpcControllerSpecLevels
        {
            get
            {
                return spcControllerSpecLevelsField;
            }
            set
            {
                spcControllerSpecLevelsField = value;
            }
        }
    }
    
    /// <summary>
    /// Boot Configuration constraint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class BootConfigurationConstraintType
    {
        #region Private fields
        private BootConfigurationOptionType bootConfigurationRequirementField;
        #endregion
        
        /// <summary>
        /// Valid boot configuration requirement for which the link map may be used.
        /// </summary>
        public BootConfigurationOptionType BootConfigurationRequirement
        {
            get
            {
                return bootConfigurationRequirementField;
            }
            set
            {
                bootConfigurationRequirementField = value;
            }
        }
    }
    
    /// <summary>
    /// Specifies the particular boot configuration this linkmap is allowed for.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public enum BootConfigurationOptionType
    {
        /// <summary>
        /// Includes show, release, test, and development boots.
        /// </summary>
        ShowAndRelease,
        /// <summary>
        /// Includes show and development boots. Excludes test and release boots.
        /// </summary>
        ShowOnly,
        /// <summary>
        /// Includes release boots, test boots and development boots. Excludes show boots.
        /// </summary>
        ReleaseOnly,
    }
    
    /// <summary>
    /// Localized text description to be displayed to the Operator explaining the intended use and/or limitations of the link map.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class OperatorDescriptionLocalizationType
    {
        #region Private fields
        private string descriptionField;
        private string cultureField;
        #endregion
        
        /// <summary>
        /// Description associated with the culture.
        /// </summary>
        public string Description
        {
            get
            {
                return descriptionField;
            }
            set
            {
                descriptionField = value;
            }
        }
        
        /// <summary>
        /// The culture associated with the localized description.
        /// </summary>
        [XmlAttribute(Form=System.Xml.Schema.XmlSchemaForm.Qualified)]
        public string Culture
        {
            get
            {
                return cultureField;
            }
            set
            {
                cultureField = value;
            }
        }
    }
    
    /// <summary>
    /// List of controller specifications.  Controller specifications are "demands" of a specific controller (or controller type) that must be satisfy for the "slot" (i.e. payvar+denom) to be playable.  Note that the specified setting are NOT always enforceable due to information limitations that vary by controller, the protocol backing an external controller, or controller protocol version.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(AnonymousType=true, Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    public partial class LinkMapTypeControllerSpecifications
    {
        #region Private fields
        private List<SpcControllerSpecificationType> spcControllerSpecificationField;
        private List<IppMLPControllerSpecificationType> ippMLPControllerSpecificationField;
        private List<NetProgressiveControllerSpecificationType> netProgressiveControllerSpecificationField;
        #endregion
        
        /// <summary>
        /// LinkMapTypeControllerSpecifications class constructor
        /// </summary>
        public LinkMapTypeControllerSpecifications()
        {
            netProgressiveControllerSpecificationField = new List<NetProgressiveControllerSpecificationType>();
            ippMLPControllerSpecificationField = new List<IppMLPControllerSpecificationType>();
            spcControllerSpecificationField = new List<SpcControllerSpecificationType>();
        }
        
        /// <summary>
        /// Standalone Progressive Controller specification.  Specifies a controller configuration and/or attributes required to satisfy this link map. This element type is specific to Standalone Progressive Controller types.
        /// </summary>
        [XmlElement("SpcControllerSpecification")]
        public List<SpcControllerSpecificationType> SpcControllerSpecification
        {
            get
            {
                return spcControllerSpecificationField;
            }
            set
            {
                spcControllerSpecificationField = value;
            }
        }
        
        /// <summary>
        /// IPP MLP controller specification.  Specifies a controller configuration and/or attributes required to satisfy this link map. MLP refers to non-zero bonus WAP, sometimes called bonus IPP.  The controller specification applies only to the IPP Protocol v8.2.
        /// </summary>
        [XmlElement("IppMLPControllerSpecification")]
        public List<IppMLPControllerSpecificationType> IppMLPControllerSpecification
        {
            get
            {
                return ippMLPControllerSpecificationField;
            }
            set
            {
                ippMLPControllerSpecificationField = value;
            }
        }
        
        /// <summary>
        /// NetProgressive controller specification.  Specifies a controller configuration and/or attributes required to satisfy this link map. This element is specific to Net Progressive Controller types.
        /// </summary>
        [XmlElement("NetProgressiveControllerSpecification")]
        public List<NetProgressiveControllerSpecificationType> NetProgressiveControllerSpecification
        {
            get
            {
                return netProgressiveControllerSpecificationField;
            }
            set
            {
                netProgressiveControllerSpecificationField = value;
            }
        }
    }
    
    /// <summary>
    /// Denomination constraint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    [XmlRootAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd", IsNullable=true)]
    public partial class DenominationConstraintType
    {
        #region Private fields
        private List<uint> denomRequirementField;
        #endregion
        
        /// <summary>
        /// DenominationConstraintType class constructor
        /// </summary>
        public DenominationConstraintType()
        {
            denomRequirementField = new List<uint>();
        }
        
        /// <summary>
        /// Valid denominations for which the link map may be used.
        /// </summary>
        [XmlElement("DenomRequirement")]
        public List<uint> DenomRequirement
        {
            get
            {
                return denomRequirementField;
            }
            set
            {
                denomRequirementField = value;
            }
        }
    }
    
    /// <summary>
    /// List of controller types allowed for the level to be linked to using legacy linking.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Xsd2Code", "4.4.0.7")]
    [Serializable]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [XmlTypeAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd")]
    [XmlRootAttribute(Namespace="F2XProgressiveLinkRegistryVer1.xsd", IsNullable=true)]
    public partial class LegacyLevelSpecificationType
    {
        #region Private fields
        private List<LegacyLevelControllerType> controllerField;
        #endregion
        
        /// <summary>
        /// LegacyLevelSpecificationType class constructor
        /// </summary>
        public LegacyLevelSpecificationType()
        {
            controllerField = new List<LegacyLevelControllerType>();
        }
        
        [XmlElement("Controller")]
        public List<LegacyLevelControllerType> Controller
        {
            get
            {
                return controllerField;
            }
            set
            {
                controllerField = value;
            }
        }
    }
}
#pragma warning restore
