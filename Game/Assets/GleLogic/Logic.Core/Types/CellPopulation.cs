using System.Collections.Generic;
using System.Linq;
using Logic.Core.Utility;
using Logic.Core.WinCheck;

namespace Logic.Core.Types
{
	/// <summary>
	/// This is a grouping of cells that which tells a Populator which cells to populate with symbols from a strip, starting at a given position
	/// (usually generated by an rng).
	/// </summary>
	public sealed class CellPopulation : IPopulation, IToString
	{
		/// <summary>
		/// The name of the cell population.
		/// </summary>
		public string Name { get; }

		/// <summary>
		/// When populating cells this is an offset into the strip allowing you to adjust where
		/// you would like to to start reading symbols to place in a given cell.
		/// Normally this will be the default of 0.
		/// The Americans normally have the middle row of a population as the
		/// first row, in this case they would use -1.
		/// </summary>
		public int StripOffset { get; }

		/// <summary>
		/// The list of cells that are required populated from a starting at a single position on a strip.
		/// </summary>
		public IReadOnlyList<Cell> Cells { get; }

		/// <summary>
		/// Constructor to initialise any required data.
		/// </summary>
		/// <param name="name">The name of the population.</param>
		/// <param name="stripOffset">The offset to populate cells from.</param>
		/// <param name="cells">The cells of this population.</param>
		public CellPopulation(string name, int stripOffset, IReadOnlyList<Cell> cells)
		{
			Name = name;
			StripOffset = stripOffset;
			Cells = cells;
		}

		public string GetPopulationName() => Name;

		public ulong GetStripOffset() => (ulong)StripOffset;

		public IReadOnlyList<Cell> GetCells() => Cells;

		/// <inheritdoc cref="IToString.ToString(string?)" />
		public IResult ToString(string format)
		{
			if (format == "ML")
			{
				var r = StringConverter.ToString(Cells, "ML");

				if (r is StringSuccess s)
				{
					var cellsLines = s.Value.ToLines();
					var ret = new List<string>
					{
						$"Name: {Name}",
						$"StripOffset: {StripOffset}",
						$"Cells: {cellsLines[0]}"
					};
					ret.AddRange(cellsLines.Skip(1).Select(l => $"       {l}"));

					return ret.Join().ToSuccess();
				}

				return r;
			}

			return new NotSupported();
		}
	}
}