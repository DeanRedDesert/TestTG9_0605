using System.Collections.Generic;
using Logic.Core.DecisionGenerator;

namespace Logic.Core.Engine
{
	/// <summary>
	/// Interface to access types in dynamically loaded dlls.
	/// </summary>
	public interface IRunner
	{
		/// <summary>
		/// Evaluate one full cycle of a stage model.
		/// This is a macro version of calling CreateInputs, ResolveMissingVariables, EvaluateStage and GenerateCycleResult in sequence.
		/// </summary>
		/// <param name="decisionGenerator">The decision generator to use for the cycle.</param>
		/// <param name="initiatingInputs">The inputs to use if the cycle is the first of a new game.</param>
		/// <param name="previousResult">The result from the previous cycle of the current game, use null if this is a new game.</param>
		/// <returns>The CycleResult for the cycle.</returns>
		CycleResult EvaluateCycle(IDecisionGenerator decisionGenerator, Inputs initiatingInputs, CycleResult previousResult);

		/// <summary>
		/// First step of running a cycle evaluation.
		/// 
		/// Will return the initiatingInputs if the previousResult is null or Finished.
		/// Otherwise will merge the previousResult inputs and any GameOutputs from the previous cycle.
		/// Note: Implementations of this step should be call CustomiseCycle.CreateInputsForCycle at appropriate times.
		/// </summary>
		/// <param name="initiatingInputs">The inputs to use if the cycle is the first of a new game.</param>
		/// <param name="previousResult">The result from the previous cycle of the current game, use null if this is a new game.</param>
		/// <returns>The inputs to use to evaluate the cycle.</returns>
		Inputs CreateInputs(Inputs initiatingInputs, CycleResult previousResult);

		/// <summary>
		/// Second step of running a cycle evaluation.
		/// 
		/// Looks a the inputs that are about to be used for the current cycle and resolves all variables that are missing for the current stage.
		/// </summary>
		/// <param name="decisionGenerator">The decision generator to use for the cycle.</param>
		/// <param name="inputs">The inputs that are about to be used for the current cycle.</param>
		/// <param name="previousResult">The result from the previous cycle of the current game, use null if this is a new game.</param>
		/// <returns>Any missing variables with their values initialised.</returns>
		IReadOnlyList<Variable> ResolveMissingVariables(IDecisionGenerator decisionGenerator, Inputs inputs, CycleResult previousResult);

		/// <summary>
		/// Third step of running a cycle evaluation.
		/// 
		/// Will use the decision generator and inputs to Evaluate the specified stage in the 'Cycle' input.
		/// </summary>
		/// <param name="decisionGenerator">The decision generator to use for the cycle.</param>
		/// <param name="inputs">The inputs to use for the current cycle.</param>
		/// <returns>The stage results that a generated during this evaluation, also the Processor results 'may' be populated during this step.</returns>
		StageResults EvaluateStage(IDecisionGenerator decisionGenerator, Inputs inputs);

		/// <summary>
		/// Fourth step of running a cycle evaluation.
		/// 
		/// Will generate the CycleResult based on the parameters.
		/// Note: Implementations of this step should be call CustomiseCycle.ProcessTriggers and CustomiseCycle.ModifyResultPostCycle
		/// at appropriate times.
		/// </summary>
		/// <param name="inputs">The inputs generated by the CreateInputs step.</param>
		/// <param name="previousResult">The result from the previous cycle of the current game, use null if this is a new game.</param>
		/// <param name="stageResults">The stageResults generated by the EvaluateStage step.</param>
		/// <returns>The CycleResult for the cycle.</returns>
		CycleResult GenerateCycleResult(Inputs inputs, CycleResult previousResult, StageResults stageResults);
	}
}